#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (constant_id = 1) const uint MAX_OBJECT_COUNT = 64;
layout (constant_id = 2) const uint MAX_INDICES = 1000;
layout (constant_id = 3) const uint MAX_ATTRIBUTES = 1000;

const uint MESH_COUNT = 30;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

struct GameObject {
    mat4 matrix;
    vec2 position;
    float angle;
    float velocity;
    float lifetime;
    uint commandIndex;
};

struct Mesh {
    uint indicesOffset;
    uint indicesCount;
    uint vertexOffset;
    uint vertexCount;
};

layout (std430, set=0, binding=0) buffer DrawCommands {
    VkDrawIndexedIndirectCommand commands[MAX_OBJECT_COUNT];
} draw;

layout (std430, set=0, binding=1) buffer DrawCommandCount {
    uint value;
} draw_count;

layout (std430, set=0, binding=2) buffer Index {
    uint values[MAX_INDICES];
} indices;

layout (std430, set=0, binding=3) buffer Attributes {
    vec4 values[MAX_ATTRIBUTES];
} attributes;

layout (std430, set=0, binding=4) buffer GameData {
    GameObject objects[MAX_OBJECT_COUNT];
    Mesh meshes[MESH_COUNT];
} game;

layout (std430, set=0, binding=5) buffer GameState {
    double currentTime;
    double pastTime;
    uint up;
    uint down;
    uint left;
    uint right;
    uint space;
    float reloadTime;
} state;

const mat4 IDENTITY = mat4(
    vec4(1.0, 0.0, 0.0, 0.0),
    vec4(0.0, 1.0, 0.0, 0.0),
    vec4(0.0, 0.0, 1.0, 0.0),
    vec4(0.0, 0.0, 0.0, 1.0)
);

void initPlayer() {
    const uint PINDICES[5] = {0, 1, 2, 3, 0};
    const vec2 POSITIONS[4] = {vec2(0.0, -0.03), vec2(0.04, 0.04), vec2(0.00, 0.02), vec2(-0.04, 0.04)};

    for (uint i=0; i<PINDICES.length(); i++) {
        indices.values[i] = PINDICES[i];
    }

    for (uint i=0; i<POSITIONS.length(); i++) {
        attributes.values[i] = vec4(POSITIONS[i], 0.0, 1.0);
    }

    game.meshes[0] = Mesh(0, PINDICES.length(), 0, POSITIONS.length());

    draw_count.value = 1;
    draw.commands[0] = VkDrawIndexedIndirectCommand(PINDICES.length(), 1, 0, 0, 0);
    game.objects[0] = GameObject(IDENTITY, vec2(0.0, 0.0), 0.0, 0.0, 0.0, 0);
} 

void initShotMesh() {
    const uint PINDICES[2] = {0, 1};
    const vec2 POSITIONS[2] = {vec2(0.0, 0.015), vec2(0.0, -0.015)};
    
    Mesh lastMesh = game.meshes[0];
    uint indicesOffset = lastMesh.indicesOffset + lastMesh.indicesCount;
    uint positionsOffset = lastMesh.vertexOffset + lastMesh.vertexCount;

    for (uint i=0; i<PINDICES.length(); i++) {
        indices.values[i+indicesOffset] = PINDICES[i];
    }

    for (uint i=0; i<POSITIONS.length(); i++) {
        attributes.values[i+positionsOffset] = vec4(POSITIONS[i], 0.0, 1.0);
    }

    game.meshes[1] = Mesh(indicesOffset, PINDICES.length(), positionsOffset, POSITIONS.length());
}

void initScoreMeshes() {
    const vec2 POSITIONS[] = {
        vec2(-0.015, -0.03), vec2(0.015, -0.03),
        vec2(-0.015,  0.00), vec2(0.015,  0.00),
        vec2(-0.015,  0.03), vec2(0.015,  0.03),};

    Mesh lastMesh = game.meshes[1];

    uint posLength = POSITIONS.length();
    uint indicesOffset = 0;
    uint positionsOffset = lastMesh.vertexOffset + lastMesh.vertexCount;
    for (uint i=0; i<POSITIONS.length(); i++) {
        attributes.values[i+positionsOffset] = vec4(POSITIONS[i], 0.0, 1.0);
    }

    // 0
    const uint pindices0[] = {0, 1, 5, 4, 0};
    indicesOffset = lastMesh.indicesOffset + lastMesh.indicesCount;
    for (uint i=0; i<pindices0.length(); i++) { indices.values[i+indicesOffset] = pindices0[i]; }
    game.meshes[2] = Mesh(indicesOffset, pindices0.length(), positionsOffset, posLength);

    // 1
    const uint pindices1[] = {1, 5};
    indicesOffset = indicesOffset + pindices0.length();
    for (uint i=0; i<pindices1.length(); i++) { indices.values[i+indicesOffset] = pindices1[i]; }
    game.meshes[3] = Mesh(indicesOffset, pindices1.length(), positionsOffset, posLength);

    // 2
    const uint pindices2[] = {0, 1, 3, 2, 4, 5};
    indicesOffset = indicesOffset + pindices1.length();
    for (uint i=0; i<pindices2.length(); i++) { indices.values[i+indicesOffset] = pindices2[i]; }
    game.meshes[4] = Mesh(indicesOffset, pindices2.length(), positionsOffset, posLength);

    // 3
    const uint pindices3[] = {0, 1, 3, 2, 3, 5, 4};
    indicesOffset = indicesOffset + pindices2.length();
    for (uint i=0; i<pindices3.length(); i++) { indices.values[i+indicesOffset] = pindices3[i]; }
    game.meshes[5] = Mesh(indicesOffset, pindices3.length(), positionsOffset, posLength);

    // 4
    const uint pindices4[] = {0, 2, 3, 1, 5};
    indicesOffset = indicesOffset + pindices3.length();
    for (uint i=0; i<pindices4.length(); i++) { indices.values[i+indicesOffset] = pindices4[i]; }
    game.meshes[6] = Mesh(indicesOffset, pindices4.length(), positionsOffset, posLength);

    // 5
    const uint pindices5[] = {1, 0, 2, 3, 5, 4};
    indicesOffset = indicesOffset + pindices4.length();
    for (uint i=0; i<pindices5.length(); i++) { indices.values[i+indicesOffset] = pindices5[i]; }
    game.meshes[7] = Mesh(indicesOffset, pindices5.length(), positionsOffset, posLength);

    // 6
    const uint pindices6[] = {1, 0, 4, 5, 3, 2};
    indicesOffset = indicesOffset + pindices5.length();
    for (uint i=0; i<pindices6.length(); i++) { indices.values[i+indicesOffset] = pindices6[i]; }
    game.meshes[8] = Mesh(indicesOffset, pindices6.length(), positionsOffset, posLength);

    // 7
    const uint pindices7[] = {0, 1, 5};
    indicesOffset = indicesOffset + pindices6.length();
    for (uint i=0; i<pindices7.length(); i++) { indices.values[i+indicesOffset] = pindices7[i]; }
    game.meshes[9] = Mesh(indicesOffset, pindices7.length(), positionsOffset, posLength);

    // 8
    const uint pindices8[] = {0, 1, 5, 4, 0, 2, 3};
    indicesOffset = indicesOffset + pindices7.length();
    for (uint i=0; i<pindices8.length(); i++) { indices.values[i+indicesOffset] = pindices8[i]; }
    game.meshes[10] = Mesh(indicesOffset, pindices8.length(), positionsOffset, posLength);

    // 9
    const uint pindices9[] = {4, 5, 1, 0, 2, 3};
    indicesOffset = indicesOffset + pindices8.length();
    for (uint i=0; i<pindices9.length(); i++) { indices.values[i+indicesOffset] = pindices9[i]; }
    game.meshes[11] = Mesh(indicesOffset, pindices9.length(), positionsOffset, posLength);
}

void initScore() {
    const uint MAX_SCORE_NUMBERS = 4;

    Mesh zeroMesh = game.meshes[2];
    uint baseObjectIndex = 1;
    uint index;
    vec2 pos = vec2(-0.95, -0.95);

    for (uint i = 0; i < MAX_SCORE_NUMBERS; i++) {
        index = baseObjectIndex+i;
        game.objects[index] = GameObject(IDENTITY, pos, 0.0, 0.0, 0.0, index);
        draw.commands[index] = VkDrawIndexedIndirectCommand(zeroMesh.indicesCount, 1, zeroMesh.indicesOffset, zeroMesh.vertexOffset, index);
        
        pos.x += 0.05;
        draw_count.value += 1;
    }
}

void initAsteroids() {
    const uint baseMeshIndex = 11;
}

void main() {
    initPlayer();
    initShotMesh();
    initScoreMeshes();
    initScore();
    initAsteroids();
    state.pastTime = state.currentTime;
    state.reloadTime = float(state.currentTime);
}
