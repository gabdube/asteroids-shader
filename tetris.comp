#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (constant_id = 1) const uint MAX_OBJECT_COUNT = 64;
layout (constant_id = 2) const uint MAX_INDICES = 1000;
layout (constant_id = 3) const uint MAX_ATTRIBUTES = 1000;

const uint MESH_COUNT = 21;
const uint MAX_ASTEROID = 20;
const uint MAX_SHOT = 20;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

struct GameObject {
    mat4 matrix;
    
    vec2 position;
    float angle;
    float velocity;
    
    float displayAngle;
    float displayAngleUpdate;

    uint toBeRemoved;

    uint commandIndex;
};

struct Mesh {
    uint indicesOffset;
    uint indicesCount;
    uint vertexOffset;
    uint vertexCount;
};

struct Asteroid {
    uint life;
    uint index;
    float radius;
};

struct Shot {
    uint objectIndex;
    float lifetime;
};

struct AsteroidArray {
    uint count;
    Asteroid asteroids[MAX_ASTEROID];
};

struct ShotArray {
    uint count;
    Shot shots[MAX_SHOT];
};

const mat4 IDENTITY = mat4(
    vec4(1.0, 0.0, 0.0, 0.0),
    vec4(0.0, 1.0, 0.0, 0.0),
    vec4(0.0, 0.0, 1.0, 0.0),
    vec4(0.0, 0.0, 0.0, 1.0)
);

layout (std430, set=0, binding=0) buffer DrawCommands {
    VkDrawIndexedIndirectCommand commands[MAX_OBJECT_COUNT];
} draw;

layout (std430, set=0, binding=1) buffer DrawCommandCount {
    uint value;
} draw_count;

layout (std430, set=0, binding=2) buffer Index {
    uint values[MAX_INDICES];
} indices;

layout (std430, set=0, binding=3) buffer Attributes {
    vec4 values[MAX_ATTRIBUTES];
} attributes;

layout (std430, set=0, binding=4) buffer GameData {
    uint currentLevel;

    uint asteroidMeshIndex;
    uint asteroidMeshCount;
    uint padding;

    GameObject objects[MAX_OBJECT_COUNT];
    Mesh meshes[MESH_COUNT];
    
    AsteroidArray asteroids;
    ShotArray shots;
} game;

layout (std430, set=0, binding=5) buffer GameState {
    double currentTime;
    double pastTime;
    uint up;
    uint left;
    uint right;
    uint space;
    float reloadTime;
} state;

// https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 19.19;
    p *= p + p;
    return fract(p);
}

bool pushArray(Asteroid obj) {
    uint count = game.asteroids.count;
    if (count == MAX_ASTEROID) {
        return false;
    }

    game.asteroids.asteroids[count] = obj;
    game.asteroids.count += 1;
    return true;
}

bool pushArray(Shot obj) {
    uint count = game.shots.count;
    if (count == MAX_SHOT) {
        return false;
    }

    game.shots.shots[count] = obj;
    game.shots.count += 1;
    return true;
}

uint nextFreeObject() {
    if (draw_count.value == MAX_OBJECT_COUNT) {
        return 0;
    } else {
        return draw_count.value;
    }
}

void instanceShot(vec2 pos, float angle) {
    const float SHOT_VELOCITY = 1.5;

    uint shotIndex = nextFreeObject();
    if (shotIndex == 0) {
        return; // no more space!!!
    }

    Shot shot = Shot(shotIndex, float(state.currentTime + 1.3));
    if (!pushArray(shot)) {
        return; // no more space!!!
    }

    // Spawn the shot just in front of the player
    vec2 relativePos = vec2(pos.x + (sin(angle) * -0.05), pos.y + (cos(angle) * -0.05));
    game.objects[shotIndex] = GameObject(IDENTITY, relativePos, angle, SHOT_VELOCITY, angle, 0.0, 0, shotIndex);

    Mesh shotMesh = game.meshes[1];
    draw.commands[shotIndex] = VkDrawIndexedIndirectCommand(shotMesh.indicesCount, 1, shotMesh.indicesOffset, shotMesh.vertexOffset, shotIndex);
    draw_count.value += 1;
}

void beginNewLevel() {
    const float PI = 3.1415926535897932384626433832795;

    if (game.asteroids.count != 0) {
        return;
    }

    float ftime = float(state.currentTime);
    float x, y, a;
    float vel = 0.5 + (0.1*float(game.currentLevel));
    uint index, meshIndex, nextCount = game.currentLevel + 5;
    float rando = 0.0;

    for (uint i = 0; i < nextCount; i++) {
        rando = hash11(rando + i + ftime);

        meshIndex = uint(hash11(rando)  * float(game.asteroidMeshCount-1));
        meshIndex = game.asteroidMeshIndex + meshIndex;
        Mesh mesh = game.meshes[meshIndex];

        index = nextFreeObject();
        if (index == 0) {
            continue;
        }

        x = (hash11(rando + i + 19.9) - 0.5) * 2;
        y = (hash11(rando + i + 9.19) - 0.5) * 2;
        a = hash11(rando + i * + 97.129) * (2*PI);

        game.objects[index] = GameObject(
            IDENTITY,
            vec2(x, y),                    // pos
            a, vel,                        // angle / vel
            a, PI,                         // display angle / display angle velocity
            0,                             // lifetime
            index
        );

        draw.commands[index] = VkDrawIndexedIndirectCommand(
            mesh.indicesCount, 1, 
            mesh.indicesOffset, mesh.vertexOffset,
            index
        );

        pushArray(Asteroid(1, index, 0.11));
        
        draw_count.value += 1;
    }

    game.asteroids.count = nextCount;
    game.currentLevel += 1;
}

void collisions() {

}

void updatePlayer(double delta) {
    GameObject player = game.objects[0];
    float angle = player.angle;
    float timeStep = float(delta / 2.0);
    vec2 pos = player.position;

    if (state.left == 1) {
        angle += timeStep * radians(360);
    } else if (state.right == 1) {
        angle -= timeStep * radians(360);
    }

    if (state.up == 1) {
        pos.x -= timeStep * sin(angle);
        pos.y -= timeStep * cos(angle);
    }

    if (state.space == 1 && state.reloadTime < state.currentTime) {
        instanceShot(pos, angle);
        state.reloadTime = float(state.currentTime + 0.20);
    }

    player.angle = angle;
    player.displayAngle = angle;
    player.position = pos;
    game.objects[0] = player;
}

void updateObjects(double delta) {
    float timeStep = float(delta / 2.0);

    uint index = 0, objectsCount = draw_count.value;
    float vel, angle, dAngle, dVel, dVelStep;
    vec2 pos, rot1, rot2;
    GameObject obj;
    Shot shot;

    while (index < objectsCount) {
        obj = game.objects[index];
        vel = obj.velocity;
        angle = obj.angle;

        dAngle = obj.displayAngle;
        dVel = obj.displayAngleUpdate;

        // Velocity
        pos = obj.position;
        pos.x -= (timeStep * sin(angle)) * vel;
        pos.y -= (timeStep * cos(angle)) * vel;

        // Angular velocity
        dAngle += timeStep * dVel;
        rot1 = vec2( cos(dAngle), -sin(dAngle) );
        rot2 = vec2( sin(dAngle),  cos(dAngle) );

        // Edge teleport
        if (pos.x > 1.1) { pos.x = -1.05;}
        else if (pos.x < -1.1) { pos.x = 1.05; }

        if (pos.y > 1.1) { pos.y = -1.05; } 
        else if (pos.y < -1.1) { pos.y = 1.05; }

        // Saving
        game.objects[index].matrix[0].xy = rot1;
        game.objects[index].matrix[1].xy = rot2;
        game.objects[index].matrix[3].xy = pos;
        game.objects[index].position = pos;
        game.objects[index].displayAngle = dAngle;

        index += 1;
    }
}

void cleanObjects() {
    float currentTime = float(state.currentTime);
    uint index = 0;
    Shot shot;

    // Shot lifetime
    while (index < game.shots.count) {
        shot = game.shots.shots[index];
        if (shot.lifetime < currentTime) {
            game.objects[shot.objectIndex].toBeRemoved = 1;
            game.shots.shots[index] = game.shots.shots[game.shots.count];
            game.shots.count -= 1;
        } else {
            index += 1;
        }
    }

}

uint updateScoreNumber(uint n, uint scoreIndex) {
    const uint BASE_NUMBER_MESH_INDEX = 2;
    const uint BASE_SCORE_OBJ_INDEX = 1;
    uint scoreObjIndex = BASE_SCORE_OBJ_INDEX+scoreIndex;

    Mesh newMesh = game.meshes[BASE_NUMBER_MESH_INDEX + n];
    draw.commands[scoreObjIndex] = VkDrawIndexedIndirectCommand(
        newMesh.indicesCount, 1,
        newMesh.indicesOffset, newMesh.vertexOffset,
        scoreObjIndex
    );

    return n;
}

void updateScore() {
    uint intTime = uint(state.currentTime);
    if (intTime > 9999) {
        intTime = 9999;
    }

    if (intTime >= 1000) {
        intTime -= updateScoreNumber((intTime / 1000), 0) * 1000;
    }

    if (intTime >= 100) {
        intTime -= updateScoreNumber((intTime / 100), 1) * 100;
    } else {
        updateScoreNumber(0, 1);
    }

    if (intTime >= 10) {
        intTime -= updateScoreNumber((intTime / 10), 2) * 10;
    } else {
        updateScoreNumber(0, 2);
    }
    
    updateScoreNumber(intTime, 3);
}

void main() {
    double delta = state.currentTime - state.pastTime;

    beginNewLevel();
    
    collisions();

    updatePlayer(delta);
    
    updateObjects(delta);
    cleanObjects();

    updateScore();
    
    state.pastTime = state.currentTime;
}
