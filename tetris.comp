#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (constant_id = 1) const uint MAX_OBJECT_COUNT = 64;
layout (constant_id = 2) const uint MAX_INDICES = 1000;
layout (constant_id = 3) const uint MAX_ATTRIBUTES = 1000;

const uint MESH_COUNT = 21;
const uint MAX_ASTEROID = 20;
const uint MAX_SHOT = 20;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

struct GameObject {
    mat4 matrix;
    
    vec2 position;
    float angle;
    float velocity;
    
    float displayAngle;
    float displayAngleUpdate;

    float lifetime;

    uint commandIndex;
};

struct Mesh {
    uint indicesOffset;
    uint indicesCount;
    uint vertexOffset;
    uint vertexCount;
};

struct Asteroid {
    uint life;
    uint index;
    float radius;
};

struct Shot {
    uint index;
};

struct AsteroidArray {
    uint count;
    Asteroid asteroids[MAX_ASTEROID];
};

struct ShotArray {
    uint count;
    Shot shots[MAX_SHOT];
};

const mat4 IDENTITY = mat4(
    vec4(1.0, 0.0, 0.0, 0.0),
    vec4(0.0, 1.0, 0.0, 0.0),
    vec4(0.0, 0.0, 1.0, 0.0),
    vec4(0.0, 0.0, 0.0, 1.0)
);

layout (std430, set=0, binding=0) buffer DrawCommands {
    VkDrawIndexedIndirectCommand commands[MAX_OBJECT_COUNT];
} draw;

layout (std430, set=0, binding=1) buffer DrawCommandCount {
    uint value;
} draw_count;

layout (std430, set=0, binding=2) buffer Index {
    uint values[MAX_INDICES];
} indices;

layout (std430, set=0, binding=3) buffer Attributes {
    vec4 values[MAX_ATTRIBUTES];
} attributes;

layout (std430, set=0, binding=4) buffer GameData {
    uint currentLevel;

    uint asteroidMeshIndex;
    uint asteroidMeshCount;
    uint padding;

    GameObject objects[MAX_OBJECT_COUNT];
    Mesh meshes[MESH_COUNT];
    
    AsteroidArray asteroids;
    ShotArray shots;
} game;

layout (std430, set=0, binding=5) buffer GameState {
    double currentTime;
    double pastTime;
    uint up;
    uint left;
    uint right;
    uint space;
    float reloadTime;
} state;

// https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 19.19;
    p *= p + p;
    return fract(p);
}

void pushArray(Asteroid obj) {
    uint count = game.asteroids.count;
    if (count == MAX_ASTEROID) {
        return;
    }

    game.asteroids.asteroids[count] = obj;
}

void pushArray(Shot obj) {
    uint count = game.shots.count;
    if (count == MAX_SHOT) {
        return;
    }

    game.shots.shots[count] = obj;
}

uint nextFreeObject() {
    if (draw_count.value == MAX_OBJECT_COUNT) {
        return 0;
    } else {
        return draw_count.value;
    }
}

void removeObject(uint index) {
    uint lastIndex = draw_count.value - 1;
    uint lastCommandIndex = game.objects[lastIndex].commandIndex;

    // Move the last object at the place of the removed object to keep things packed.
    if (index != lastIndex) {
        GameObject lastObj = game.objects[lastIndex];
        VkDrawIndexedIndirectCommand lastCmd = draw.commands[lastObj.commandIndex];

        GameObject obj = game.objects[index];
        VkDrawIndexedIndirectCommand cmd = draw.commands[obj.commandIndex];

        lastObj.commandIndex = obj.commandIndex;
        lastCmd.firstInstance = cmd.firstInstance;

        game.objects[index] = lastObj;
        draw.commands[obj.commandIndex] = lastCmd;
    }

    // Disable the last object
    game.objects[lastIndex].commandIndex = 0;
    draw.commands[lastCommandIndex].indexCount = 0;

    draw_count.value -= 1;
}

void shotInstance(vec2 pos, float angle) {
    const float SHOT_VELOCITY = 1.5;

    uint shotIndex = nextFreeObject();
    if (shotIndex == 0) {
        return; // no more space!!!
    }

    vec2 truePos = vec2(pos.x + (sin(angle) * -0.05), pos.y + (cos(angle) * -0.05));

    Mesh shotMesh = game.meshes[1];
    game.objects[shotIndex] = GameObject(IDENTITY, truePos, angle, SHOT_VELOCITY, angle, 0.0, float(state.currentTime + 1.3), shotIndex);
    draw.commands[shotIndex] = VkDrawIndexedIndirectCommand(shotMesh.indicesCount, 1, shotMesh.indicesOffset, shotMesh.vertexOffset, shotIndex);
    draw_count.value += 1;

    pushArray(Shot(shotIndex));
}

void updatePlayer(double delta) {
    GameObject player = game.objects[0];
    float angle = player.angle;
    float timeStep = float(delta / 2.0);
    vec2 pos = player.position;

    if (state.left == 1) {
        angle += timeStep * radians(360);
    } else if (state.right == 1) {
        angle -= timeStep * radians(360);
    }

    if (state.up == 1) {
        pos.x -= timeStep * sin(angle);
        pos.y -= timeStep * cos(angle);
    }

    if (pos.x > 1.05) { pos.x = -1.02;}
    else if (pos.x < -1.05) { pos.x = 1.02; }

    if (pos.y > 1.05) { pos.y = -1.02; } 
    else if (pos.y < -1.05) { pos.y = 1.02; }
    
    player.matrix = mat4(
        vec4(cos(angle), -sin(angle), 0.0, 0.0),
        vec4(sin(angle), cos(angle), 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(pos.x, pos.y, 0.0, 1.0)
    );
    player.angle = angle;
    player.position = pos;
    game.objects[0] = player;
}

void playerShoot() {
    if (state.space == 1 && state.reloadTime < state.currentTime) {
        shotInstance(game.objects[0].position, game.objects[0].angle);
        state.reloadTime = float(state.currentTime + 0.20);
    }
}

void cleanObjects() {
    uint index = 0;
    while (index < draw_count.value) {
        if (game.objects[index].commandIndex != 0) {
            float life = game.objects[index].lifetime;
            if (life > 0 && life < state.currentTime) {
                removeObject(index);
            }
        }
        index += 1;
    }
}

void updateObjects(double delta) {
    uint index = 0;
    uint updatedCount = 0;
    uint objectsCount = draw_count.value;
    float timeStep = float(delta / 2.0);

    float vel, angle, dAngle, dVel, dVelStep;
    vec2 pos, rot1, rot2;
    GameObject obj;

    while (updatedCount < objectsCount && index < MAX_OBJECT_COUNT) {
        if (game.objects[index].commandIndex != 0) {
            obj = game.objects[index];
            vel = obj.velocity;
            angle = obj.angle;

            dAngle = obj.displayAngle;
            dVel = obj.displayAngleUpdate;

            // Velocity
            pos = obj.position;
            pos.x -= (timeStep * sin(angle)) * vel;
            pos.y -= (timeStep * cos(angle)) * vel;

            // Angular velocity
            dAngle += timeStep * dVel;
            rot1 = vec2( cos(dAngle), -sin(dAngle) );
            rot2 = vec2( sin(dAngle),  cos(dAngle) );

            // Edge teleport
            if (pos.x > 1.05) { pos.x = -1.02;}
            else if (pos.x < -1.05) { pos.x = 1.02; }

            if (pos.y > 1.05) { pos.y = -1.02; } 
            else if (pos.y < -1.05) { pos.y = 1.02; }

            // Saving
            game.objects[index].matrix[0].xy = rot1;
            game.objects[index].matrix[1].xy = rot2;
            game.objects[index].matrix[3].xy = pos;
            game.objects[index].position = pos;
            game.objects[index].displayAngle = dAngle;
            updatedCount += 1;
        }

        index += 1;
    }
}

uint updateScoreNumber(uint n, uint scoreIndex) {
    const uint BASE_NUMBER_MESH_INDEX = 2;
    const uint BASE_SCORE_OBJ_INDEX = 1;
    uint scoreObjIndex = BASE_SCORE_OBJ_INDEX+scoreIndex;

    Mesh newMesh = game.meshes[BASE_NUMBER_MESH_INDEX + n];
    draw.commands[scoreObjIndex] = VkDrawIndexedIndirectCommand(
        newMesh.indicesCount, 1,
        newMesh.indicesOffset, newMesh.vertexOffset,
        scoreObjIndex
    );

    return n;
}

void updateScore() {
    uint intTime = uint(state.currentTime);
    if (intTime > 9999) {
        intTime = 9999;
    }

    if (intTime >= 1000) {
        intTime -= updateScoreNumber((intTime / 1000), 0) * 1000;
    }

    if (intTime >= 100) {
        intTime -= updateScoreNumber((intTime / 100), 1) * 100;
    } else {
        updateScoreNumber(0, 1);
    }

    if (intTime >= 10) {
        intTime -= updateScoreNumber((intTime / 10), 2) * 10;
    } else {
        updateScoreNumber(0, 2);
    }
    
    updateScoreNumber(intTime, 3);
}

void beginNewLevel() {
    const float PI = 3.1415926535897932384626433832795;

    if (game.asteroids.count != 0) {
        return;
    }

    float ftime = float(state.currentTime);
    float x, y, a;
    float vel = 0.5 + (0.1*float(game.currentLevel));
    uint index, meshIndex, nextCount = game.currentLevel + 5;
    float rando = 0.0;

    for (uint i = 0; i < nextCount; i++) {
        rando = hash11(rando + i + ftime);

        meshIndex = uint(hash11(rando)  * float(game.asteroidMeshCount-1));
        meshIndex = game.asteroidMeshIndex + meshIndex;
        Mesh mesh = game.meshes[meshIndex];

        index = nextFreeObject();
        if (index == 0) {
            continue;
        }

        x = (hash11(rando + i + 19.9) - 0.5) * 2;
        y = (hash11(rando + i + 9.19) - 0.5) * 2;
        a = hash11(rando + i * + 97.129) * (2*PI);

        game.objects[index] = GameObject(
            IDENTITY,
            vec2(x, y),                    // pos
            a, vel,                        // angle / vel
            a, PI,                         // display angle / display angle velocity
            0.0,                           // lifetime
            index
        );

        draw.commands[index] = VkDrawIndexedIndirectCommand(
            mesh.indicesCount, 1, 
            mesh.indicesOffset, mesh.vertexOffset,
            index
        );

        pushArray(Asteroid(1, index, 0.11));
        
        draw_count.value += 1;
    }

    game.asteroids.count = nextCount;
    game.currentLevel += 1;
}

void collisions() {

}

void main() {
    double delta = state.currentTime - state.pastTime;

    beginNewLevel();
    
    collisions();

    updatePlayer(delta);
    playerShoot();
    
    cleanObjects();
    updateObjects(delta);

    updateScore();
    
    state.pastTime = state.currentTime;
}
